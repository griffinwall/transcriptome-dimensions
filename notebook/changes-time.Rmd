---
title: "Myeloma dimensions for tracking changes over time"
output:
  html_document:
    theme: united
    highlight: tango
  html_notebook: default
params:
  score: /Users/rosal/OneDrive - University of Utah/2020/analyze/data/transcriptome-dimensions/analysis/score.csv
  gene_loadings: /Users/rosal/OneDrive - University of Utah/2020/analyze/data/transcriptome-dimensions/analysis/pca_gene_loadings.csv
  data: /Users/rosal/OneDrive - University of Utah/2020/analyze/data/transcriptome-dimensions/analysis/20200802_pipe_out.rdata
---

```{r load_packages, message=F, include=F}
# Install and load required R packages
library(dplyr)
library(data.table)
library(ggplot2)
library(MASS)
library(survivalAnalysis)
library(sva)
```

Load data
```{r}
load(file = params$data) # load processed data
gene.load = read.csv(file = params$gene_loadings) %>% data.table()# dimension gene loadings
pca.score = read.csv(file = params$score) %>% data.table() # dimension values
load(file = "rdata/mod.clinical-risk.rdata") # baseline clinical risk models
```

### 1. Derive dimensions in longitudinal samples

Find gene level expression from aggregated transcripts
```{r}
eps = exp_time[gene_name %in% gene.load$GENE_NAME] %>% dplyr::select("gene_name",contains("MMRF"))  # Select genes in dimensions
gene = data.table(aggregate(. ~ gene_name, data = eps, FUN = sum)) # Aggregate transcript counts to gene_name counts
```

1.2. FIND SAMPLES WITH < 90% COVERAGE ACROSS "GOOD" GENES 
```{r}
remove.samples = gene[,-"gene_name"][,lapply(.SD,function(x)sum(x<100)/length(gene.load$GENE_NAME))] %>% # For each sample, find proportion of genes with <100 reads
  select_if(. > 0.1) %>% colnames() # List samples with > 10% of genes with < 100 counts
print(paste0(length(remove.samples)," sample(s) had <100 reads in > 10% of high-quality genes with and was removed. Sample(s) removed: ",remove.samples))
```

1.3. SUBSET TO DIMENSION GENES & REMOVE "BAD" SAMPLES
```{r}
qc.counts = exp_time[gene_name %in% gene.load$GENE_NAME] %>% # Select keep genes
  dplyr::select(-seqid,-gene_id,-gene_biotype,-all_of(remove.samples)) # Remove extra gene annotation and poor coverage samples
qc.melt <- data.table::melt(qc.counts, # transform format
  id.vars=c("gene_name","name_n_transcripts","transcript_id","length"),
  variable.name="SEQ_ID",
  value.name="count")
rm(qc.counts,eps,gene,remove.samples) # cleanup variables
```

1.4. NORMALIZE AND ADJUST BY SIZE FACTOR
```{r}
qc.melt[,total_raw_counts:=sum(count),by=c('SEQ_ID','gene_name')] # Find total counts per sample per gene
qc.melt[,kb_length:=length/1000] # Find length of gene in kilo-bases
final.dt = qc.melt[,list(cpk=sum((count+1/name_n_transcripts)/kb_length)), # Find counts per gene length
                   by=c('SEQ_ID','gene_name','total_raw_counts')] # For each sample and gene pair
final.dt[,size_factor:=median(cpk),by='SEQ_ID'] # Find size factor = median counts/gene length
final.dt[,cpkmed:=cpk/size_factor] # Normalize by size factor
final.dt[,logcpkmed:=log2(cpkmed)] # Log2 transform
```

1.5. TRUNCATE VALUES +/- 5 SD FROM MEAN NORMALIZED GENE COUNT 
```{r}
final.dt[,mean:=mean(logcpkmed),by='gene_name'] # Find mean of normalized gene counts per gene
final.dt[,sd:=sd(logcpkmed),by='gene_name'] # Find standard deviation of normalized counts per gene
final.dt[,adjlogcpkmed:=logcpkmed] # New variable to adjust
final.dt[(logcpkmed-mean)/sd>=5,adjlogcpkmed:=mean+5*sd] # Truncate values > 5 SD
final.dt[(logcpkmed-mean)/sd<= -5,adjlogcpkmed:=mean-5*sd] # Truncate values < 5 SD
```

1.6. CONVERT TO SAMPLE X GENE MATRIX FORMAT
```{r}
norm <- list("melt"=final.dt)
norm.dt <- dcast(norm$melt, SEQ_ID ~ gene_name, value.var='adjlogcpkmed') # Sample x gene
rm(final.dt,norm) # cleanup variables
```

1.7. ANNOTATE BATCH & COVARIATES FROM CLINICAL DATA
```{r}
vr = c("SEQ_ID","batch","D_PT_age","D_PT_gender","ttcos","censos","ttcpfs","censpfs","ttctf1","censtf1")
cin_vr = clinical %>% dplyr::select(all_of(vr))
dt = merge(cin_vr,norm.dt,by="SEQ_ID")
```

1.8. RUN COMBAT TO ADJUST EXPRESSION DATA
```{r}
# SETUP VARIABLES
DAT = dt %>% dplyr::select(-all_of(vr)) %>% t() # Expression only and gene x sample format
colnames(DAT) = dt$SEQ_ID # Annotate samples to DAT
BATCH = as.numeric(dt$batch)
MOD = dt %>% dplyr::select(all_of(vr[3:10])) %>% data.matrix() # Co-variate model

# RUN COMBAT
cbat = ComBat(dat = DAT, batch = BATCH, mod = MOD)
cbat.dt = data.table(t(cbat)) # Sample x gene data table
cbat.dt$SEQ_ID = colnames(cbat) # Annotate sample ids

rm(vr,cin_vr,dt,DAT,BATCH,MOD,cbat) # Cleanup variables
```

1.9. DERIVE DIMENSIONS
```{r}
dim_time = cbind(cbat.dt[,"SEQ_ID"],scale(data.matrix(cbat.dt[,-"SEQ_ID"]),center=gene.load$CENTER_MEAN,scale = FALSE) %*% data.matrix(gene.load[,-c("GENE_NAME","CENTER_MEAN")]))
# Note, dimension values in baseline samples are slightly different as batch correction included a different sample set
```
1.10. STANDARDIZE TO DIMENSIONS
```{r}
pca.sd = apply(pca.score[,-"SEQ_ID"],2,sd) # find standard deviation of original MM dimensions
tme.sd = cbind(dim_time[,"SEQ_ID"],data.matrix(dim_time[,-"SEQ_ID"]) %*% diag(1/pca.sd)) # divide by SD
colnames(tme.sd) = c("SEQ_ID",paste(colnames(dim_time[,-"SEQ_ID"]),"_SD",sep = ""))
```

### PLOT SPECTRA CHART OVER TIME
Select samples for MMRF 1157
```{r}
ids = unique(dt.melt[grep("1157",dt.melt$SEQ_ID),]$SEQ_ID)
```

TIdy data
```{r}
out = data.frame(SEQ_ID=character(),
                 variable=factor(),
                 value=numeric(),
                 perc=numeric())

for (i in seq_along(ids)){
  data = dt.melt[SEQ_ID==ids[i]]
  tot = sum(abs(data$value)) 
  data$perc = abs(data$value)/tot
  out = rbind(out,data)
}
out$id = gsub("_BM","",gsub("MMRF_","",out$SEQ_ID))

out$lv = if_else(out$value < -2, -2,
                 if_else(out$value > 2, 2, out$value))
out
```

Plot
```{r}
theme_set(theme_minimal() + theme(axis.title=element_text(size=9), axis.text=element_text(size=8), 
                                  legend.title=element_text(size=9), legend.text=element_text(size=8)))

dset = ids
p_a = ggplot(data=out[SEQ_ID%in%dset],aes(x=id, y=abs(value), fill=lv, group=variable)) +
  geom_bar(stat = "identity",position = position_stack(reverse = TRUE), color="black", width=0.9) +
  scale_fill_gradient2(low="#00A087",mid="white",high="#3C5488",midpoint=0) +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        legend.position = "right",
        panel.grid = element_blank()) +
  xlab("patient") + ylab("spectra") + 
  labs(fill = "value") +
  coord_flip()
ggsave(filename = "plots/spectra_time.png",plot = p_a,width=7.5,height=5.5)
p_a
```


### 2. PSL changes over times
**clinical risk**
Merge with clinical data
```{r}
dt = merge(
  clinical[,c("SEQ_ID","PUBLIC_ID","COLLECTION_REASON","VJ_INTERVAL",
              "D_TRI_CF_ABNORMALITYPR11","D_TRI_CF_ABNORMALITYPR8",
              "D_TRI_CF_ABNORMALITYPR13","D_TRI_CF_ABNORMALITYPR3",
              "D_TRI_CF_ABNORMALITYPR6","D_TRI_CF_1PAMPLIFICATI2",
              "D_TRI_CF_T1416ABNORMAL")],
  tme.sd,by="SEQ_ID")

dt.melt = melt(tme.sd,id.vars = "SEQ_ID") #reformat for plotting
```

2.2 t(14;16): D_TRI_CF_ABNORMALITYPR8

Find samples that acquire t(14;16) over time
```{r}
nab = dt[VJ_INTERVAL=="Baseline" & D_TRI_CF_ABNORMALITYPR8=="No"]$PUBLIC_ID
pid = dt[PUBLIC_ID%in%nab & D_TRI_CF_ABNORMALITYPR8=="Yes"]$PUBLIC_ID
ex = dt[PUBLIC_ID%in%pid,c("PUBLIC_ID","SEQ_ID","COLLECTION_REASON","VJ_INTERVAL","D_TRI_CF_ABNORMALITYPR8")]$SEQ_ID

pdtm = dt.melt[dt.melt$SEQ_ID%in%ex]
```

Compute poly-spectra liability (PSL) score at each time point
```{r}
pdt = dt[SEQ_ID%in%ex]
fit = mod.risk$t1416
fit.coeff = summary(fit)$coeff[-1,] %>% data.table()
#fit.coeff$PC = colnames(dt[,-c("SEQ_ID","score")])
pdt[,psl:= rowSums(data.matrix(pdt %>% dplyr::select(contains("PC"))) %*% diag(fit.coeff$Estimate)) + summary(fit)$coeff[1,1]]
#pdt = data.frame(age = md$model$D_PT_age,predictors = md$fitted.values,psl = dt$psl)

pdt
```

Plot dimension profiles for **MMRF 2373**
```{r}
# data tidy
ids = c("MMRF_2373_1_BM","MMRF_2373_2_BM")
dat = dt.melt[SEQ_ID%in%ids] # select samples
dat$sign <- ifelse(dat$value >= 0, "positive", "negative")

out = data.frame(SEQ_ID=character(),
                 variable=factor(),
                 value=numeric(),
                 sign=character(),
                 perc=numeric())

for (i in seq_along(ids)){
  data = dat[SEQ_ID==ids[i]]
  tot = sum(abs(data$value)) 
  data$perc = abs(data$value)/tot
  out = rbind(out,data)
}

out$id = gsub("_BM","",gsub("MMRF_","",out$SEQ_ID))

out$lv = if_else(out$value < -2, -2,
                 if_else(out$value > 2, 2, out$value))

theme_set(theme_minimal() + theme(axis.title=element_text(size=9), axis.text=element_text(size=8), 
                                  legend.title=element_text(size=9), legend.text=element_text(size=8)))

dset = ids #[c(1:2,11:12)]
```

Plot Spectra Chart
```{r}
dt = out
dt$abs_value = abs(dt$value)
#dt

dt_spread = tidyr::spread(dt[,c("id","variable","abs_value")], id, abs_value)
dt_spread$y = cumsum(dt_spread[,2])
dt_spread$yend = cumsum(dt_spread[,3])
dt_spread$x = 1 + 0.8/2
dt_spread$xend = 2 - 0.8/2
#dt_spread

p2 = ggplot() +
  geom_bar(data = dt,aes(x = id, y = abs_value, fill = lv, group = variable),
           stat = "identity",position = position_stack(reverse = TRUE), color="black", width=0.8) +
  scale_fill_gradient2(low="#00A087",mid="white",high="#3C5488",midpoint=0) + 
  geom_segment(data = dt_spread,aes(x = x, xend = xend, y = y, yend = yend)) +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        axis.title.y = element_blank(), legend.position = "right",
        panel.grid = element_blank()) +
  xlab("patient") + ylab("spectra") + 
  #ylim(c(0,43)) +
  labs(fill = "value") + 
  #scale_y_continuous(limits=c(0, 45)) +
  coord_flip()
#ggsave(filename = "plots/spectra_2.pdf",plot = p2,width=7.5,height=3.5)
p2
```
Plot settings
```{r}
theme_set(theme_classic() + 
            theme(legend.position="none",legend.key.size = unit(0.5,"line"),
                  legend.title = element_text(size=8),
                  legend.text = element_text(size=7),
                  axis.title=element_text(size=9),
                  axis.text=element_text(size=8)))
```


Plot PSL Score change on baseline waterfall plot
```{r}
pdt[,c("SEQ_ID","psl")] # capture time-point PSL



load(file = "rdata/mod.clinical-risk.rdata") # baseline clinical risk models
fit = mod.risk$t1416 # find baseline waterfall
pdt1 = data.frame(t1416 = fit$model$D_TRI_CF_ABNORMALITYPR8,predictors = fit$linear.predictors)

#nrow(pdt1)

setorder(pdt1,predictors)
w = ggplot(pdt1,aes(y=predictors,x=1:nrow(pdt1),fill=t1416)) +
  geom_bar(stat="identity") +
  scale_fill_manual(values = c("gray","red"), name = "t(14;16)", labels = c("N (n=501)","Y (n=53)")) +
  xlab("Patients (N=554)") + ylab("PSL Score") +
  scale_x_continuous(limits = c(0,nrow(pdt1)+1), breaks=seq(1,nrow(pdt1),1)) +
  #theme(legend.position = "top",
  theme(legend.position = c(0.05,1), legend.justification = c(0.05,1),
        axis.text = element_blank(), axis.ticks = element_blank()) +
  geom_hline(yintercept=-1.6374314,color = "gray", size=1) +
  geom_hline(yintercept=-0.6486604,color = "red", size=1)
w
#ggsave(filename = "plots/t1114_waterfall.pdf",plot = w,width=4,height=1.75)
```

